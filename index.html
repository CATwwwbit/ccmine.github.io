<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EndMeow</title>
    <!-- –ó–∞–≥—Ä—É–∑–∫–∞ Three.js –∏ PointerLockControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <!-- –ó–∞–≥—Ä—É–∑–∫–∞ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Inter', sans-serif; 
        }
        canvas { display: block; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 16px;
            height: 16px;
            margin-top: -8px;
            margin-left: -8px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }
        .block-item {
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            position: relative; 
        }
        .block-item:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .selected-block {
            border: 4px solid #facc15; /* Yellow border for selection */
            transform: scale(1.1);
        }
        #fullInventory {
            display: none;
            cursor: default;
        }
        .inventory-slot {
            width: 64px;
            height: 64px;
            border: 3px solid #4b5563; /* Gray-700 */
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: border-color 0.15s;
            overflow: hidden; 
        }
        .inventory-slot span {
            position: absolute;
            font-size: 0.75rem; /* text-xs */
            padding: 2px 4px;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 3px;
        }
        .inventory-slot:hover {
            border-color: #facc15; /* Yellow */
        }
        #messageBox {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ef4444; /* Red-500 */
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        /* –°—Ç–∏–ª—å –¥–ª—è –∫–Ω–æ–ø–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è */
        #saveButton {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 30;
            transition: background-color 0.2s;
        }
        #saveButton:hover {
            background-color: #2563eb;
        }
        #saveButton:disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
        }
        /* –°—Ç–∏–ª–∏ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ */
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        .explosion-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #FFD700;
            border-radius: 50%;
            pointer-events: none;
            z-index: 20;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="messageBox" role="alert"></div>
    
    <!-- –ö–Ω–æ–ø–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –º–∏—Ä–∞ -->
    <button id="saveButton" title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –º–∏—Ä (F5)">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –º–∏—Ä</button>
    
    <!-- –°—Ç–∞—Ä—Ç–æ–≤—ã–π –æ–≤–µ—Ä–ª–µ–π -->
    <div id="overlay" class="fixed inset-0 bg-gray-900 bg-opacity-70 flex flex-col items-center justify-center text-white z-50">
        <div class="p-8 rounded-lg shadow-2xl bg-gray-800 max-w-lg text-center">
            <h1 class="text-3xl font-bold mb-4">–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ EndMeow!</h1>
            <p class="mb-6">–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∏ —É–ø—Ä–∞–≤–ª—è—Ç—å –∫–∞–º–µ—Ä–æ–π.</p>
            <div class="text-left bg-gray-700 p-4 rounded-md">
                <p class="font-semibold mb-2 text-yellow-300">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</p>
                <ul class="list-disc list-inside space-y-1 text-sm">
                    <li><span class="font-mono bg-gray-600 px-1 rounded">WASD</span> ‚Äî –î–≤–∏–∂–µ–Ω–∏–µ (–í–ø–µ—Ä–µ–¥, –ù–∞–∑–∞–¥, –í–ª–µ–≤–æ, –í–ø—Ä–∞–≤–æ)</li>
                    <li><span class="font-mono bg-gray-600 px-1 rounded">Space</span> ‚Äî –ü—Ä—ã–∂–æ–∫</li>
                    <li><span class="font-mono bg-gray-600 px-1 rounded">Shift</span> ‚Äî **–ü—Ä–∏—Å–µ—Å—Ç—å (—É–¥–µ—Ä–∂–∏–≤–∞—Ç—å)**</li>
                    <li><span class="font-mono bg-gray-600 px-1 rounded">–õ–µ–≤–∞—è –ö–Ω–æ–ø–∫–∞ –ú—ã—à–∏</span> ‚Äî –õ–æ–º–∞—Ç—å –±–ª–æ–∫</li>
                    <li><span class="font-mono bg-gray-600 px-1 rounded">–ü—Ä–∞–≤–∞—è –ö–Ω–æ–ø–∫–∞ –ú—ã—à–∏</span> ‚Äî –°—Ç–∞–≤–∏—Ç—å –±–ª–æ–∫ / –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å</li>
                    <li><span class="font-mono bg-gray-600 px-1 rounded">1-9</span> / <span class="font-mono bg-gray-600 px-1 rounded">–ö–æ–ª–µ—Å–æ –ú—ã—à–∏</span> ‚Äî –°–º–µ–Ω–∏—Ç—å —Å–ª–æ—Ç</li>
                    <li><span class="font-mono bg-gray-600 px-1 rounded">E</span> ‚Äî –û—Ç–∫—Ä—ã—Ç—å/–ó–∞–∫—Ä—ã—Ç—å –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</li>
                    <li><span class="font-mono bg-gray-600 px-1 rounded">F5</span> ‚Äî –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –º–∏—Ä</li>
                    <li><span class="font-mono bg-gray-600 px-1 rounded">F</span> ‚Äî –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –¥–∏–Ω–∞–º–∏—Ç (–≤–∑—Ä—ã–≤ —á–µ—Ä–µ–∑ 3 —Å–µ–∫)</li>
                    <li><span class="font-mono bg-gray-600 px-1 rounded">ESC</span> ‚Äî –í—ã–π—Ç–∏ –∏–∑ —Ä–µ–∂–∏–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</li>
                </ul>
            </div>
            
            <div class="mt-6 flex flex-col space-y-4">
                <button id="startButton" class="px-6 py-3 bg-green-500 hover:bg-green-600 text-white font-bold rounded-full transition duration-150 shadow-lg">
                    –ù–∞—á–∞—Ç—å –ù–æ–≤—É—é –ò–≥—Ä—É
                </button>
                
                <div class="file-input-wrapper">
                    <button class="w-full px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white font-bold rounded-full transition duration-150 shadow-lg">
                        üìÅ –ó–∞–≥—Ä—É–∑–∏—Ç—å –ú–∏—Ä
                    </button>
                    <input type="file" id="loadWorldInput" accept=".json" />
                </div>
            </div>
            
            <p class="mt-4 text-sm text-gray-400">–ò–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–∞–π–ª –º–∏—Ä–∞ —Å—é–¥–∞</p>
        </div>
    </div>

    <!-- –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –≤–Ω–∏–∑—É —ç–∫—Ä–∞–Ω–∞ (–ë—ã—Å—Ç—Ä–∞—è –ø–∞–Ω–µ–ª—å) -->
    <div id="inventory" class="fixed bottom-4 left-1/2 -translate-x-1/2 flex space-x-2 z-20">
        <!-- –ë–ª–æ–∫–∏ –±—É–¥—É—Ç –≤—Å—Ç–∞–≤–ª–µ–Ω—ã —Å—é–¥–∞ —Å –ø–æ–º–æ—â—å—é JavaScript -->
    </div>

    <!-- –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–º–µ–Ω–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –±–ª–æ–∫–∞ -->
    <div id="blockNameDisplay" class="fixed bottom-24 left-1/2 -translate-x-1/2 text-white bg-gray-800 bg-opacity-70 px-4 py-2 rounded-lg font-bold text-lg pointer-events-none z-20">
        –¢—Ä–∞–≤–∞
    </div>

    <!-- –ü–æ–ª–Ω—ã–π –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å (–°–∫—Ä—ã—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é) -->
    <div id="fullInventory" class="fixed inset-0 bg-gray-900 bg-opacity-90 flex items-center justify-center text-white z-50">
        <div class="p-8 rounded-lg shadow-2xl bg-gray-800 w-full max-w-4xl max-h-[80vh] overflow-y-auto">
            <h2 class="text-2xl font-bold mb-6 text-yellow-300">–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å (–ù–∞–∂–º–∏—Ç–µ 'E' –∏–ª–∏ ESC –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è)</h2>
            <div id="inventoryGrid" class="grid grid-cols-10 gap-4">
                <!-- –í—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –±–ª–æ–∫–∏ –¥–ª—è "–≤–∑—è—Ç–∏—è" –±—É–¥—É—Ç –∑–¥–µ—Å—å -->
            </div>
            <p class="mt-6 text-sm text-gray-400">–ö–ª–∏–∫–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å –±–ª–æ–∫ –∏ –ø–æ–º–µ—Å—Ç–∏—Ç—å –µ–≥–æ –≤ —Ç–µ–∫—É—â–∏–π —Å–ª–æ—Ç –±—ã—Å—Ç—Ä–æ–π –ø–∞–Ω–µ–ª–∏.</p>
        </div>
    </div>

    <script>
        // --- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –ò–≥—Ä–æ–∫–∞ –∏ –°–∫–æ—Ä–æ—Å—Ç–∏ ---
        const BLOCK_SIZE = 1; // –†–∞–∑–º–µ—Ä –æ–¥–Ω–æ–≥–æ –±–ª–æ–∫–∞ –≤ Three.js
        const PLAYER_HEIGHT = 2.0; // –í—ã—Å–æ—Ç–∞ –∏–≥—Ä–æ–∫–∞ 2 –±–ª–æ–∫–∞
        const EYE_HEIGHT = 1.8;    // –í—ã—Å–æ—Ç–∞ –≥–ª–∞–∑ –æ—Ç –ø–æ–ª–∞
        const PLAYER_HALF_WIDTH = 0.3; // –†–∞–¥–∏—É—Å –∫–æ–ª–ª–∏–∑–∏–∏ –∏–≥—Ä–æ–∫–∞
        const COLLISION_CHECK_OFFSET = PLAYER_HALF_WIDTH * 0.7; // –°–º–µ—â–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–ª–ª–∏–∑–∏–π
        
        const CROUCH_HEIGHT = 1.4; // –í—ã—Å–æ—Ç–∞ –ø—Ä–∏ –ø—Ä–∏—Å–µ–¥–∞–Ω–∏–∏
        const CROUCH_EYE_HEIGHT = 1.2; // –í—ã—Å–æ—Ç–∞ –≥–ª–∞–∑ –ø—Ä–∏ –ø—Ä–∏—Å–µ–¥–∞–Ω–∏–∏
        const MAX_SPEED = 10.0; // –ë–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
        const CROUCH_SPEED_FACTOR = 0.4; // –ú–Ω–æ–∂–∏—Ç–µ–ª—å —Å–∫–æ—Ä–æ—Å—Ç–∏ –ø—Ä–∏ –ø—Ä–∏—Å–µ–¥–∞–Ω–∏–∏
        const GRAVITY_CONSTANT = 9.8 * 5.0; // –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–∏
        
        // --- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ---
        let camera, scene, renderer, controls;
        let raycaster;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let prevTime = performance.now();
        
        // --- –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä–æ–∫–∞ ---
        const velocity = new THREE.Vector3(); // –°–∫–æ—Ä–æ—Å—Ç—å –∏–≥—Ä–æ–∫–∞ (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è)
        let intersectedBlock = null; // –ë–ª–æ–∫, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π —Å–º–æ—Ç—Ä–∏—Ç –∏–≥—Ä–æ–∫
        let highlightMesh; // –°–µ—Ç–∫–∞ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –±–ª–æ–∫–∞
        
        let isInventoryOpen = false;
        let isCrouching = false;
        let currentHeight = PLAYER_HEIGHT; // –¢–µ–∫—É—â–∞—è –≤—ã—Å–æ—Ç–∞ –∏–≥—Ä–æ–∫–∞
        let currentEyeHeight = EYE_HEIGHT; // –¢–µ–∫—É—â–∞—è –≤—ã—Å–æ—Ç–∞ –≥–ª–∞–∑
        
        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –¥–≤–∏–∂–µ–Ω–∏—è
        const forwardVector = new THREE.Vector3();
        const rightVector = new THREE.Vector3();
        
        // --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ë–ª–æ–∫–æ–≤ ---
        const QUICKBAR_SIZE = 9;
        const BLOCK_TYPES = {
            1: { name: '–¢—Ä–∞–≤–∞', color: 0x38761d, functional: false, defaultColor: 0x38761d, isClimbable: false }, 
            2: { name: '–ó–µ–º–ª—è', color: 0x654321, functional: false, defaultColor: 0x654321, isClimbable: false },  
            3: { name: '–ö–∞–º–µ–Ω—å', color: 0x808080, functional: false, defaultColor: 0x808080, isClimbable: false }, 
            4: { name: '–î–µ—Ä–µ–≤–æ', color: 0x8B4513, functional: false, defaultColor: 0x8B4513, isClimbable: false }, 
            5: { name: '–ü–µ—Å–æ–∫', color: 0xFAD985, functional: false, defaultColor: 0xFAD985, isClimbable: false },
            6: { name: '–õ—é–∫ (Toggle)', color: 0x8B4513, functional: true, defaultColor: 0x8B4513, isClimbable: false }, 
            7: { name: '–ö–∏—Ä–ø–∏—á', color: 0xB22222, functional: false, defaultColor: 0xB22222, isClimbable: false }, 
            8: { name: '–°—Ç–µ–∫–ª–æ', color: 0xADD8E6, functional: false, defaultColor: 0xADD8E6, isClimbable: false, isTransparent: true }, 
            9: { name: '–õ–µ—Å—Ç–Ω–∏—Ü–∞', color: 0x774936, functional: false, defaultColor: 0x774936, isClimbable: true }, 
            10: { name: '–õ–∏—Å—Ç–≤–∞', color: 0x00A000, functional: false, defaultColor: 0x00A000, isClimbable: false, isTransparent: true }, 
            11: { name: '–°—É–Ω–¥—É–∫ (Open E)', color: 0x964b00, functional: true, defaultColor: 0x964b00, isClimbable: false }, 
            12: { name: '–ê–ª–º–∞–∑–Ω—ã–π –ë–ª–æ–∫', color: 0x00FFFF, functional: false, defaultColor: 0x00FFFF, isClimbable: false }, 
            13: { name: '–ó–æ–ª–æ—Ç–æ–π –ë–ª–æ–∫', color: 0xFFD700, functional: false, defaultColor: 0xFFD700, isClimbable: false }, 
            14: { name: '–û–±—Å–∏–¥–∏–∞–Ω', color: 0x2C2255, functional: false, defaultColor: 0x2C2255, isClimbable: false }, 
            15: { name: '–°–Ω–µ–≥', color: 0xFFFFFF, functional: false, defaultColor: 0xFFFFFF, isClimbable: false }, 
            16: { name: '–õ—ë–¥', color: 0x99FFFF, functional: false, defaultColor: 0x99FFFF, isClimbable: false, isTransparent: true }, 
            17: { name: '–ö–≤–∞—Ä—Ü', color: 0xE8E8E8, functional: false, defaultColor: 0xE8E8E8, isClimbable: false }, 
            18: { name: '–ù–µ–∑–µ—Ä—Ä–∞–∫', color: 0x4C2A4C, functional: false, defaultColor: 0x4C2A4C, isClimbable: false }, 
            19: { name: '–ü–ª–∏—Ç—ã', color: 0xA0A0A0, functional: false, defaultColor: 0xA0A0A0, isClimbable: false }, 
            20: { name: '–î–≤–µ—Ä—å (2 –±–ª–æ–∫–∞)', color: 0x8B4513, functional: true, defaultColor: 0x8B4513, isClimbable: false, isDoor: true }, 
            21: { name: '–ò–∑—É–º—Ä—É–¥', color: 0x00FF00, functional: false, defaultColor: 0x00FF00, isClimbable: false }, 
            22: { name: '–õ–∞–∑—É—Ä–∏—Ç', color: 0x0000FF, functional: false, defaultColor: 0x0000FF, isClimbable: false }, 
            23: { name: '–†–µ–¥—Å—Ç–æ—É–Ω', color: 0xFF0000, functional: false, defaultColor: 0xFF0000, isClimbable: false }, 
            24: { name: '–ñ–µ–ª–µ–∑–æ', color: 0xD8D8D8, functional: false, defaultColor: 0xD8D8D8, isClimbable: false }, 
            25: { name: '–£–≥–æ–ª—å', color: 0x333333, functional: false, defaultColor: 0x333333, isClimbable: false }, 
            26: { name: '–ö–Ω–∏–∂–Ω–∞—è –ø–æ–ª–∫–∞', color: 0x8B4513, functional: false, defaultColor: 0x8B4513, isClimbable: false }, 
            27: { name: '–¢—ã–∫–≤–∞', color: 0xFFA500, functional: false, defaultColor: 0xFFA500, isClimbable: false }, 
            28: { name: '–ê—Ä–±—É–∑', color: 0x90EE90, functional: false, defaultColor: 0x90EE90, isClimbable: false }, 
            29: { name: '–ú–∏—Ñ—Ä–∏–ª', color: 0x87CEEB, functional: false, defaultColor: 0x87CEEB, isClimbable: false }, 
            30: { name: '–ü–æ—Ä—Ç–∞–ª', color: 0x800080, functional: true, defaultColor: 0x800080, isClimbable: false }, 
            31: { name: '–ö–∞–∫—Ç—É—Å', color: 0x00AA00, functional: false, defaultColor: 0x00AA00, isClimbable: false }, 
            32: { name: '–î–∏–Ω–∞–º–∏—Ç', color: 0xFF4444, functional: true, defaultColor: 0xFF4444, isClimbable: false, isTNT: true }, 
        };
        
        let quickbarBlocks = [1, 2, 3, 4, 5, 6, 7, 8, 9]; // –ë–ª–æ–∫–∏ –≤ –±—ã—Å—Ç—Ä–æ–π –ø–∞–Ω–µ–ª–∏
        let selectedQuickbarSlot = 0; 
        let selectedBlockId = quickbarBlocks[selectedQuickbarSlot]; 

        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –¥–∏–Ω–∞–º–∏—Ç–∞
        let activeTNTs = new Map(); // Map –¥–ª—è –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–∏–Ω–∞–º–∏—Ç–∞: id -> {mesh, timer, position}

        // --- Three.js –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ---
        function init() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–∞—á–∞–ª—å–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –∫–∞–º–µ—Ä—ã
            const groundSurfaceY = BLOCK_SIZE + BLOCK_SIZE / 2; 
            camera.position.y = groundSurfaceY + EYE_HEIGHT; 
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // –ù–µ–±–æ
            scene.fog = new THREE.Fog(0x87CEEB, 0, 200);

            // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—ã —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–µ–π –∫–∞–º–µ—Ä—ã
            controls = new THREE.PointerLockControls(camera, document.body);
            
            // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –∫–∞–º–µ—Ä–∞ –Ω–µ –Ω–∞–∫–ª–æ–Ω–µ–Ω–∞
            camera.rotation.order = 'YXZ'; // –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –≤—Ä–∞—â–µ–Ω–∏—è –¥–ª—è FPS –∫–∞–º–µ—Ä—ã

            const startButton = document.getElementById('startButton');
            const loadWorldInput = document.getElementById('loadWorldInput');
            const overlay = document.getElementById('overlay');
            
            startButton.addEventListener('click', () => {
                controls.lock();
            }, false);

            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–≥—Ä—É–∑–∫–∏ –º–∏—Ä–∞
            loadWorldInput.addEventListener('change', handleWorldFileLoad);

            // Drag and drop –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –º–∏—Ä–∞
            document.addEventListener('dragover', (e) => {
                e.preventDefault();
                overlay.classList.add('border-2', 'border-blue-500', 'border-dashed');
            });

            document.addEventListener('dragleave', (e) => {
                e.preventDefault();
                if (!e.relatedTarget || !overlay.contains(e.relatedTarget)) {
                    overlay.classList.remove('border-2', 'border-blue-500', 'border-dashed');
                }
            });

            document.addEventListener('drop', (e) => {
                e.preventDefault();
                overlay.classList.remove('border-2', 'border-blue-500', 'border-dashed');
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type === 'application/json') {
                    loadWorldFromFile(files[0]);
                } else {
                    showMessage("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –º–∏—Ä–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON");
                }
            });

            controls.addEventListener('lock', function () {
                overlay.style.display = 'none';
                if (isInventoryOpen) toggleInventory(false);
            });
            controls.addEventListener('unlock', function () {
                overlay.style.display = 'flex';
                // –ü—Ä–∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–µ –∫—É—Ä—Å–æ—Ä–∞, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –∏ –ø—Ä–∏—Å–µ–¥–∞–Ω–∏–µ
                moveForward = moveBackward = moveLeft = moveRight = false;
                velocity.set(0, 0, 0);
                if (isCrouching) toggleCrouch(false); 
            });
            scene.add(controls.getObject());

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 5); // –õ—É—á –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –±–ª–æ–∫–∞–º–∏

            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1.5, 1).normalize();
            scene.add(directionalLight);
            
            // –°–µ—Ç–∫–∞ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –±–ª–æ–∫–∞
            const highlightGeometry = new THREE.BoxGeometry(BLOCK_SIZE * 1.002, BLOCK_SIZE * 1.002, BLOCK_SIZE * 1.002);
            const highlightMaterial = new THREE.MeshBasicMaterial({
                color: 0xeeeeee,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            highlightMesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
            highlightMesh.visible = false;
            scene.add(highlightMesh);

            generateWorld();

            setupInventory();
            updateInventorySelection();
            updateBlockNameDisplay(); 

            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('wheel', onMouseWheel, false);
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
            document.getElementById('saveButton').addEventListener('click', saveWorldToFile);
        }

        // --- –§—É–Ω–∫—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –º–∏—Ä–∞ –≤ —Ñ–∞–π–ª ---
        function saveWorldToFile() {
            try {
                // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –º–∏—Ä–∞
                const worldData = {
                    blocks: [],
                    player: {
                        position: {
                            x: camera.position.x,
                            y: camera.position.y,
                            z: camera.position.z
                        },
                        quickbarBlocks: [...quickbarBlocks],
                        selectedQuickbarSlot: selectedQuickbarSlot
                    },
                    metadata: {
                        version: "1.0",
                        saveDate: new Date().toISOString(),
                        blockCount: worldBlocks.size
                    }
                };

                // –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –≤—Å–µ—Ö –±–ª–æ–∫–∞—Ö
                worldBlocks.forEach((block, coords) => {
                    worldData.blocks.push({
                        x: block.position.x,
                        y: block.position.y,
                        z: block.position.z,
                        typeId: block.userData.typeId,
                        isOpen: block.userData.isOpen || false,
                        isDoor: block.userData.isDoor || false,
                        doorPart: block.userData.doorPart || null,
                        doorId: block.userData.doorId || null
                    });
                });

                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ JSON
                const worldJson = JSON.stringify(worldData, null, 2);
                
                // –°–æ–∑–¥–∞–µ–º Blob –∏ —Å—Å—ã–ª–∫—É –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
                const blob = new Blob([worldJson], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é —Å—Å—ã–ª–∫—É –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
                const a = document.createElement('a');
                a.href = url;
                a.download = `endmeow_world_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–∞–º—è—Ç—å
                URL.revokeObjectURL(url);
                
                showMessage(`–ú–∏—Ä —Å–æ—Ö—Ä–∞–Ω–µ–Ω! –ë–ª–æ–∫–æ–≤: ${worldBlocks.size}`);
                console.log('–ú–∏—Ä —Å–æ—Ö—Ä–∞–Ω–µ–Ω:', worldData);
                
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –º–∏—Ä–∞:', error);
                showMessage('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –º–∏—Ä–∞!');
            }
        }

        // --- –§—É–Ω–∫—Ü–∏–∏ –∑–∞–≥—Ä—É–∑–∫–∏ –º–∏—Ä–∞ ---
        function handleWorldFileLoad(event) {
            const file = event.target.files[0];
            if (file) {
                loadWorldFromFile(file);
            }
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ input, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–æ—Ç –∂–µ —Ñ–∞–π–ª —Å–Ω–æ–≤–∞
            event.target.value = '';
        }

        function loadWorldFromFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const worldData = JSON.parse(e.target.result);
                    loadWorldData(worldData);
                    showMessage(`–ú–∏—Ä –∑–∞–≥—Ä—É–∂–µ–Ω! –ë–ª–æ–∫–æ–≤: ${worldData.blocks.length}`);
                    
                    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞—á–∏–Ω–∞–µ–º –∏–≥—Ä—É –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏
                    controls.lock();
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–∏—Ä–∞:', error);
                    showMessage('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–∏—Ä–∞! –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞.');
                }
            };
            
            reader.onerror = function() {
                showMessage('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞!');
            };
            
            reader.readAsText(file);
        }

        function loadWorldData(worldData) {
            // –û—á–∏—â–∞–µ–º —Ç–µ–∫—É—â–∏–π –º–∏—Ä
            clearWorld();
            
            // –ó–∞–≥—Ä—É–∂–∞–µ–º –±–ª–æ–∫–∏
            worldData.blocks.forEach(blockData => {
                addBlock(blockData.x, blockData.y, blockData.z, blockData.typeId);
                
                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –±–ª–æ–∫–æ–≤
                const block = getBlockAtCoords(blockData.x, blockData.y, blockData.z);
                if (block) {
                    if (blockData.isOpen !== undefined) {
                        block.userData.isOpen = blockData.isOpen;
                        if (block.userData.typeId === 6) { // –õ—é–∫
                            block.material.color.set(blockData.isOpen ? 0x4a2c16 : BLOCK_TYPES[6].defaultColor);
                        }
                    }
                    
                    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–≤–µ—Ä–µ–π
                    if (blockData.isDoor) {
                        block.userData.isDoor = true;
                        block.userData.doorPart = blockData.doorPart;
                        block.userData.doorId = blockData.doorId;
                        block.userData.isOpen = blockData.isOpen || false;
                        
                        if (blockData.isOpen) {
                            block.material.color.set(0x5a3c26); // –¶–≤–µ—Ç –æ—Ç–∫—Ä—ã—Ç–æ–π –¥–≤–µ—Ä–∏
                        }
                    }
                }
            });
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
            if (worldData.player) {
                const playerPos = worldData.player.position;
                camera.position.set(playerPos.x, playerPos.y, playerPos.z);
                
                if (worldData.player.quickbarBlocks) {
                    quickbarBlocks = [...worldData.player.quickbarBlocks];
                    selectedQuickbarSlot = worldData.player.selectedQuickbarSlot || 0;
                    selectedBlockId = quickbarBlocks[selectedQuickbarSlot];
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º UI
                    setupInventory();
                    updateInventorySelection();
                    updateBlockNameDisplay();
                }
            }
            
            console.log('–ú–∏—Ä –∑–∞–≥—Ä—É–∂–µ–Ω:', worldData);
        }

        function clearWorld() {
            // –£–¥–∞–ª—è–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –∏–∑ —Å—Ü–µ–Ω—ã
            worldBlocks.forEach((block) => {
                scene.remove(block);
            });
            worldBlocks.clear();
        }

        // --- –í—Å–ø–ª—ã–≤–∞—é—â–µ–µ –°–æ–æ–±—â–µ–Ω–∏–µ ---
        function showMessage(text) {
            const messageBox = document.getElementById('messageBox');
            messageBox.textContent = text;
            messageBox.style.opacity = 1;

            clearTimeout(window.messageTimeout);
            window.messageTimeout = setTimeout(() => {
                messageBox.style.opacity = 0;
            }, 3000);
        }

        // --- –õ–æ–≥–∏–∫–∞ –ú–∏—Ä–∞ –∏ –ë–ª–æ–∫–æ–≤ ---
        const worldBlocks = new Map();
        const blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        let doorCounter = 0; // –°—á–µ—Ç—á–∏–∫ –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö ID –¥–≤–µ—Ä–µ–π
        let tntCounter = 0; // –°—á–µ—Ç—á–∏–∫ –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö ID –¥–∏–Ω–∞–º–∏—Ç–∞
        
        function getBlockAtCoords(x, y, z) {
            // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –±–ª–æ–∫–∞
            const blockX = Math.round(x / BLOCK_SIZE);
            const blockY = Math.round(y / BLOCK_SIZE);
            const blockZ = Math.round(z / BLOCK_SIZE);
            return worldBlocks.get(`${blockX},${blockY},${blockZ}`);
        }

        function isBlockSolid(x, y, z) {
            const block = getBlockAtCoords(x, y, z);
            if (!block) return false;
            
            const typeInfo = BLOCK_TYPES[block.userData.typeId];

            if (typeInfo.isClimbable) return false; // –õ–µ—Å—Ç–Ω–∏—Ü–∞ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ç–≤–µ—Ä–¥–æ–π –¥–ª—è –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–π –∫–æ–ª–ª–∏–∑–∏–∏
            if (block.userData.typeId === 6 && block.userData.isOpen) return false; // –û—Ç–∫—Ä—ã—Ç—ã–π –ª—é–∫ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ç–≤–µ—Ä–¥—ã–º
            if (block.userData.isDoor && block.userData.isOpen) return false; // –û—Ç–∫—Ä—ã—Ç–∞—è –¥–≤–µ—Ä—å –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ç–≤–µ—Ä–¥–æ–π
            
            return true;
        }

        function addBlock(x, y, z, typeId) {
            const blockInfo = BLOCK_TYPES[typeId];
            if (!blockInfo) return;

            const coords = `${x / BLOCK_SIZE},${y / BLOCK_SIZE},${z / BLOCK_SIZE}`;
            if (worldBlocks.has(coords)) return;

            let material;
            if (blockInfo.isTransparent) {
                // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ–≥–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è —Å—Ç–µ–∫–ª–∞ –∏–ª–∏ –ª–∏—Å—Ç–≤—ã)
                material = new THREE.MeshLambertMaterial({ 
                    color: blockInfo.defaultColor, 
                    transparent: true, 
                    opacity: 0.7 
                });
            } else {
                material = new THREE.MeshLambertMaterial({ color: blockInfo.defaultColor });
            }
            
            const mesh = new THREE.Mesh(blockGeometry, material);
            mesh.position.set(x, y, z);
            
            // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –±–ª–æ–∫–∞
            mesh.userData.coords = coords;
            mesh.userData.typeId = typeId;
            mesh.userData.isFunctional = blockInfo.functional || blockInfo.isClimbable;
            
            if (blockInfo.functional && blockInfo.name.includes('–õ—é–∫')) {
                mesh.userData.isOpen = false; 
            }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–≤–µ—Ä–µ–π
            if (blockInfo.isDoor) {
                mesh.userData.isDoor = true;
                mesh.userData.doorPart = 'bottom'; // –ù–∏–∂–Ω—è—è —á–∞—Å—Ç—å –¥–≤–µ—Ä–∏
                mesh.userData.doorId = doorCounter;
                
                // –°–æ–∑–¥–∞–µ–º –≤–µ—Ä—Ö–Ω—é—é —á–∞—Å—Ç—å –¥–≤–µ—Ä–∏
                const topMesh = new THREE.Mesh(blockGeometry, material);
                topMesh.position.set(x, y + BLOCK_SIZE, z);
                const topCoords = `${x / BLOCK_SIZE},${(y + BLOCK_SIZE) / BLOCK_SIZE},${z / BLOCK_SIZE}`;
                
                topMesh.userData.coords = topCoords;
                topMesh.userData.typeId = typeId;
                topMesh.userData.isFunctional = true;
                topMesh.userData.isDoor = true;
                topMesh.userData.doorPart = 'top';
                topMesh.userData.doorId = doorCounter;
                topMesh.userData.isOpen = false;
                
                scene.add(topMesh);
                worldBlocks.set(topCoords, topMesh);
                
                doorCounter++;
            }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∏–Ω–∞–º–∏—Ç–∞
            if (blockInfo.isTNT) {
                mesh.userData.isTNT = true;
                mesh.userData.tntId = tntCounter++;
                mesh.userData.isActive = false;
            }

            scene.add(mesh);
            worldBlocks.set(mesh.userData.coords, mesh);
            return mesh;
        }

        function generateTree(startX, startY, startZ) {
            const trunkHeight = Math.floor(Math.random() * 3) + 3; 

            // 1. –°—Ç–≤–æ–ª (–î–µ—Ä–µ–≤–æ - ID 4)
            for (let h = 0; h < trunkHeight; h++) {
                addBlock(startX, startY + h * BLOCK_SIZE, startZ, 4);
            }

            // 2. –õ–∏—Å—Ç–≤–∞ (ID 10) - –ö—Ä–æ–Ω–∞
            const leavesCenterY = startY + (trunkHeight) * BLOCK_SIZE;
            const leavesRadius = 1.5; // –†–∞–¥–∏—É—Å –∫—Ä–æ–Ω—ã

            for (let x = startX - BLOCK_SIZE; x <= startX + BLOCK_SIZE; x += BLOCK_SIZE) {
                for (let y = leavesCenterY; y <= leavesCenterY + BLOCK_SIZE * 2; y += BLOCK_SIZE) {
                    for (let z = startZ - BLOCK_SIZE; z <= startZ + BLOCK_SIZE; z += BLOCK_SIZE) {
                        
                        const dx = (x - startX) / BLOCK_SIZE;
                        const dy = (y - leavesCenterY) / BLOCK_SIZE;
                        const dz = (z - startZ) / BLOCK_SIZE;
                        
                        // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º—ã (—ç–ª–ª–∏–ø—Å–æ–∏–¥)
                        if ((dx * dx + dy * dy / 4 + dz * dz) < leavesRadius) {
                            const block = getBlockAtCoords(x, y, z);
                            // –°—Ç–∞–≤–∏–º –ª–∏—Å—Ç–≤—É, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–∞–º –Ω–µ —Å—Ç–≤–æ–ª
                            if (!block || block.userData.typeId !== 4) { 
                                addBlock(x, y, z, 10);
                            }
                        }
                    }
                }
            }
        }

        function generateCactus(startX, startY, startZ) {
            const height = Math.floor(Math.random() * 3) + 2; // –í—ã—Å–æ—Ç–∞ –∫–∞–∫—Ç—É—Å–∞ 2-4 –±–ª–æ–∫–∞
            for (let h = 0; h < height; h++) {
                addBlock(startX, startY + h * BLOCK_SIZE, startZ, 31);
            }
        }

        function generateWorld() {
            const worldSize = 30;
            
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–∞–Ω–¥—à–∞—Ñ—Ç–∞ —Å –ø–µ—Å—á–∞–Ω—ã–º–∏ –¥–æ–ª–∏–Ω–∞–º–∏
            for (let x = -worldSize; x <= worldSize; x++) {
                for (let z = -worldSize; z <= worldSize; z++) {
                    const blockX = x * BLOCK_SIZE;
                    const blockZ = z * BLOCK_SIZE;
                    
                    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –±–∏–æ–º–∞
                    const isDesert = Math.abs(x) > 10 || Math.abs(z) > 10; // –ü–µ—Å—á–∞–Ω—ã–µ –¥–æ–ª–∏–Ω—ã –ø–æ –∫—Ä–∞—è–º
                    
                    if (isDesert) {
                        // –ü–µ—Å—á–∞–Ω–∞—è –¥–æ–ª–∏–Ω–∞
                        addBlock(blockX, 0 * BLOCK_SIZE, blockZ, 5); // –ü–µ—Å–æ–∫ –≤–Ω–∏–∑—É
                        addBlock(blockX, 1 * BLOCK_SIZE, blockZ, 5); // –ü–µ—Å–æ–∫ –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
                        
                        // –ö–∞–∫—Ç—É—Å—ã –≤ –ø—É—Å—Ç—ã–Ω–µ
                        if (Math.random() < 0.05) {
                            generateCactus(blockX, 2 * BLOCK_SIZE, blockZ);
                        }
                    } else {
                        // –û–±—ã—á–Ω–∞—è –∑–µ–ª–µ–Ω–∞—è –∑–æ–Ω–∞
                        addBlock(blockX, 0 * BLOCK_SIZE, blockZ, 2); // –ó–µ–º–ª—è
                        addBlock(blockX, 1 * BLOCK_SIZE, blockZ, 1); // –¢—Ä–∞–≤–∞
                        
                        // –î–µ—Ä–µ–≤—å—è —Ç–æ–ª—å–∫–æ –≤ –∑–µ–ª–µ–Ω–æ–π –∑–æ–Ω–µ
                        if (Math.random() < 0.03) {
                            generateTree(blockX, 1 * BLOCK_SIZE, blockZ);
                        }
                    }
                }
            }
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ/–¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–µ –±–ª–æ–∫–∏
            addBlock(5 * BLOCK_SIZE, 2 * BLOCK_SIZE, 0 * BLOCK_SIZE, 11); // –°—É–Ω–¥—É–∫
            addBlock(6 * BLOCK_SIZE, 2 * BLOCK_SIZE, 0 * BLOCK_SIZE, 12); // –ê–ª–º–∞–∑–Ω—ã–π –ë–ª–æ–∫
            addBlock(7 * BLOCK_SIZE, 2 * BLOCK_SIZE, 0 * BLOCK_SIZE, 13); // –ó–æ–ª–æ—Ç–æ–π –ë–ª–æ–∫
            addBlock(8 * BLOCK_SIZE, 2 * BLOCK_SIZE, 0 * BLOCK_SIZE, 9); // –õ–µ—Å—Ç–Ω–∏—Ü–∞
            addBlock(8 * BLOCK_SIZE, 3 * BLOCK_SIZE, 0 * BLOCK_SIZE, 9); // –õ–µ—Å—Ç–Ω–∏—Ü–∞
            
            // –°–æ–∑–¥–∞–µ–º –¥–æ–º —Å –¥–≤–µ—Ä—å—é
            const houseX = 10 * BLOCK_SIZE;
            const houseZ = 5 * BLOCK_SIZE;
            
            // –°—Ç–µ–Ω—ã –¥–æ–º–∞
            for (let y = 1; y <= 3; y++) {
                for (let x = -2; x <= 2; x++) {
                    addBlock(houseX + x * BLOCK_SIZE, y * BLOCK_SIZE, houseZ - 2 * BLOCK_SIZE, 7); // –ó–∞–¥–Ω—è—è —Å—Ç–µ–Ω–∞
                    addBlock(houseX + x * BLOCK_SIZE, y * BLOCK_SIZE, houseZ + 2 * BLOCK_SIZE, 7); // –ü–µ—Ä–µ–¥–Ω—è—è —Å—Ç–µ–Ω–∞
                }
                for (let z = -1; z <= 1; z++) {
                    addBlock(houseX - 2 * BLOCK_SIZE, y * BLOCK_SIZE, houseZ + z * BLOCK_SIZE, 7); // –õ–µ–≤–∞—è —Å—Ç–µ–Ω–∞
                    addBlock(houseX + 2 * BLOCK_SIZE, y * BLOCK_SIZE, houseZ + z * BLOCK_SIZE, 7); // –ü—Ä–∞–≤–∞—è —Å—Ç–µ–Ω–∞
                }
            }
            
            // –ö—Ä—ã—à–∞
            for (let x = -2; x <= 2; x++) {
                for (let z = -2; z <= 2; z++) {
                    addBlock(houseX + x * BLOCK_SIZE, 4 * BLOCK_SIZE, houseZ + z * BLOCK_SIZE, 4); // –î–µ—Ä–µ–≤—è–Ω–Ω–∞—è –∫—Ä—ã—à–∞
                }
            }
            
            // –î–≤–µ—Ä—å
            addBlock(houseX, 1 * BLOCK_SIZE, houseZ + 2 * BLOCK_SIZE, 20); // –î–≤–µ—Ä—å
            
            // –û–∫–Ω–∞
            addBlock(houseX - 2 * BLOCK_SIZE, 2 * BLOCK_SIZE, houseZ, 8); // –°—Ç–µ–∫–ª—è–Ω–Ω–æ–µ –æ–∫–Ω–æ
            addBlock(houseX + 2 * BLOCK_SIZE, 2 * BLOCK_SIZE, houseZ, 8); // –°—Ç–µ–∫–ª—è–Ω–Ω–æ–µ –æ–∫–Ω–æ
            
            // –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —É–±—Ä–∞–Ω—Å—Ç–≤–æ
            addBlock(houseX - 1 * BLOCK_SIZE, 1 * BLOCK_SIZE, houseZ - 1 * BLOCK_SIZE, 11); // –°—É–Ω–¥—É–∫ –≤–Ω—É—Ç—Ä–∏
            addBlock(houseX + 1 * BLOCK_SIZE, 1 * BLOCK_SIZE, houseZ, 14); // –û–±—Å–∏–¥–∏–∞–Ω –≤–Ω—É—Ç—Ä–∏
            
            // –®–∞—Ö—Ç–∞ —Å —Ä—É–¥–∞–º–∏
            for (let i = 0; i < 10; i++) {
                addBlock(-5 * BLOCK_SIZE, -i * BLOCK_SIZE, -5 * BLOCK_SIZE, 24); // –ñ–µ–ª–µ–∑–æ
                addBlock(-6 * BLOCK_SIZE, -i * BLOCK_SIZE, -5 * BLOCK_SIZE, 25); // –£–≥–æ–ª—å
                addBlock(-7 * BLOCK_SIZE, -i * BLOCK_SIZE, -5 * BLOCK_SIZE, 21); // –ò–∑—É–º—Ä—É–¥
            }
            
            // –ü–∏—Ä–∞–º–∏–¥–∞ –∏–∑ –Ω–æ–≤—ã—Ö –±–ª–æ–∫–æ–≤ –≤ –ø—É—Å—Ç—ã–Ω–µ
            const pyramidX = -15 * BLOCK_SIZE;
            const pyramidZ = -15 * BLOCK_SIZE;
            const pyramidBlocks = [21, 22, 23, 29]; // –ò–∑—É–º—Ä—É–¥, –õ–∞–∑—É—Ä–∏—Ç, –†–µ–¥—Å—Ç–æ—É–Ω, –ú–∏—Ñ—Ä–∏–ª
            
            for (let level = 0; level < 4; level++) {
                const size = 4 - level;
                for (let x = -size; x <= size; x++) {
                    for (let z = -size; z <= size; z++) {
                        const blockType = pyramidBlocks[level % pyramidBlocks.length];
                        addBlock(pyramidX + x * BLOCK_SIZE, (level + 1) * BLOCK_SIZE, pyramidZ + z * BLOCK_SIZE, blockType);
                    }
                }
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–º–Ω–æ–≥–æ –¥–∏–Ω–∞–º–∏—Ç–∞ –≤ –º–∏—Ä –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            addBlock(-8 * BLOCK_SIZE, 2 * BLOCK_SIZE, -8 * BLOCK_SIZE, 32);
            addBlock(-10 * BLOCK_SIZE, 2 * BLOCK_SIZE, -10 * BLOCK_SIZE, 32);
        }

        // --- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –¥–∏–Ω–∞–º–∏—Ç–∞ ---
        function activateTNT(mesh) {
            if (!mesh || !mesh.userData.isTNT || mesh.userData.isActive) return;
            
            mesh.userData.isActive = true;
            const tntId = mesh.userData.tntId;
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –≤–∑—Ä—ã–≤–∞ (3 —Å–µ–∫—É–Ω–¥—ã)
            const timer = setTimeout(() => {
                explodeTNT(mesh);
            }, 3000);
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∞–∫—Ç–∏–≤–Ω–æ–º –¥–∏–Ω–∞–º–∏—Ç–µ
            activeTNTs.set(tntId, {
                mesh: mesh,
                timer: timer,
                position: mesh.position.clone()
            });
            
            // –í–∏–∑—É–∞–ª—å–Ω–∞—è –∏–Ω–¥–∏–∫–∞—Ü–∏—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ (–º–∏–≥–∞–Ω–∏–µ)
            let blinkCount = 0;
            const maxBlinks = 6;
            const originalColor = mesh.material.color.clone();
            
            const blinkInterval = setInterval(() => {
                if (blinkCount >= maxBlinks * 2) {
                    clearInterval(blinkInterval);
                    return;
                }
                
                if (blinkCount % 2 === 0) {
                    mesh.material.color.set(0xFFFFFF); // –ë–µ–ª—ã–π —Ü–≤–µ—Ç –ø—Ä–∏ –º–∏–≥–∞–Ω–∏–∏
                } else {
                    mesh.material.color.copy(originalColor);
                }
                blinkCount++;
            }, 250);
            
            showMessage("–î–∏–Ω–∞–º–∏—Ç –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! –í–∑—Ä—ã–≤ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã!");
        }

        function explodeTNT(mesh) {
            if (!mesh) return;
            
            const explosionRadius = 4; // –†–∞–¥–∏—É—Å –≤–∑—Ä—ã–≤–∞ –≤ –±–ª–æ–∫–∞—Ö
            const explosionCenter = mesh.position;
            
            // –°–æ–∑–¥–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞
            createExplosionEffect(explosionCenter);
            
            // –£–¥–∞–ª—è–µ–º –±–ª–æ–∫–∏ –≤ —Ä–∞–¥–∏—É—Å–µ –≤–∑—Ä—ã–≤–∞
            const blocksToRemove = [];
            
            for (let x = -explosionRadius; x <= explosionRadius; x++) {
                for (let y = -explosionRadius; y <= explosionRadius; y++) {
                    for (let z = -explosionRadius; z <= explosionRadius; z++) {
                        const distance = Math.sqrt(x*x + y*y + z*z);
                        if (distance <= explosionRadius) {
                            const blockX = explosionCenter.x + x * BLOCK_SIZE;
                            const blockY = explosionCenter.y + y * BLOCK_SIZE;
                            const blockZ = explosionCenter.z + z * BLOCK_SIZE;
                            
                            const block = getBlockAtCoords(blockX, blockY, blockZ);
                            if (block && block.userData.typeId !== 14) { // –û–±—Å–∏–¥–∏–∞–Ω –Ω–µ —Ä–∞–∑—Ä—É—à–∞–µ—Ç—Å—è –≤–∑—Ä—ã–≤–æ–º
                                blocksToRemove.push(block);
                            }
                        }
                    }
                }
            }
            
            // –£–¥–∞–ª—è–µ–º –±–ª–æ–∫–∏
            blocksToRemove.forEach(block => {
                removeBlock(block);
            });
            
            // –£–¥–∞–ª—è–µ–º —Å–∞–º –¥–∏–Ω–∞–º–∏—Ç
            removeBlock(mesh);
            
            // –£–¥–∞–ª—è–µ–º –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö TNT
            if (mesh.userData.tntId !== undefined) {
                activeTNTs.delete(mesh.userData.tntId);
            }
            
            showMessage("–ë–£–ú! –î–∏–Ω–∞–º–∏—Ç –≤–∑–æ—Ä–≤–∞–ª—Å—è!");
        }

        function createExplosionEffect(center) {
            // –°–æ–∑–¥–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤–∑—Ä—ã–≤–∞
            const particleCount = 50;
            for (let i = 0; i < particleCount; i++) {
                createParticle(center);
            }
            
            // –í—Ä–µ–º–µ–Ω–Ω–æ–µ –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞ (—ç—Ñ—Ñ–µ–∫—Ç –≤—Å–ø—ã—à–∫–∏)
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = 'white';
            flash.style.opacity = '0.3';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '15';
            document.body.appendChild(flash);
            
            setTimeout(() => {
                document.body.removeChild(flash);
            }, 100);
        }

        function createParticle(center) {
            const particle = document.createElement('div');
            particle.className = 'explosion-particle';
            
            // –°–ª—É—á–∞–π–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ —Å–∫–æ—Ä–æ—Å—Ç—å
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 3;
            const vx = Math.cos(angle) * speed;
            const vy = -2 - Math.random() * 3; // –í–≤–µ—Ä—Ö —Å —Ä–∞–∑–Ω–æ–π —Å–∏–ª–æ–π
            const vz = Math.sin(angle) * speed;
            
            let x = 0, y = 0, z = 0;
            const startX = center.x;
            const startY = center.y;
            const startZ = center.z;
            
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º 3D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ 2D —ç–∫—Ä–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (—É–ø—Ä–æ—â–µ–Ω–Ω–æ)
            function updatePosition() {
                x += vx * 0.1;
                y += vy * 0.1;
                z += vz * 0.1;
                vy += 0.1; // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                
                // –ü—Ä–æ–µ—Ü–∏—Ä—É–µ–º 3D –ø–æ–∑–∏—Ü–∏—é –Ω–∞ 2D —ç–∫—Ä–∞–Ω
                const screenX = (x + startX) * 10 + window.innerWidth / 2;
                const screenY = window.innerHeight / 2 - (y + startY) * 10;
                
                particle.style.left = screenX + 'px';
                particle.style.top = screenY + 'px';
                
                // –£–º–µ–Ω—å—à–∞–µ–º —Ä–∞–∑–º–µ—Ä —á–∞—Å—Ç–∏—Ü—ã —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
                const scale = 1 - (Math.abs(y) / 10);
                particle.style.transform = `scale(${Math.max(0, scale)})`;
                
                if (y > 5 || scale <= 0) {
                    document.body.removeChild(particle);
                    return false;
                }
                return true;
            }
            
            document.body.appendChild(particle);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è —á–∞—Å—Ç–∏—Ü—ã
            const animateParticle = () => {
                if (updatePosition()) {
                    requestAnimationFrame(animateParticle);
                }
            };
            
            animateParticle();
        }

        function removeBlock(mesh) {
            if (!mesh || mesh.userData.coords === undefined) return;
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –¥–≤–µ—Ä–µ–π
            if (mesh.userData.isDoor) {
                const doorId = mesh.userData.doorId;
                
                // –ù–∞—Ö–æ–¥–∏–º –∏ —É–¥–∞–ª—è–µ–º –æ–±–µ —á–∞—Å—Ç–∏ –¥–≤–µ—Ä–∏
                worldBlocks.forEach((block, coords) => {
                    if (block.userData.doorId === doorId) {
                        scene.remove(block);
                        worldBlocks.delete(coords);
                    }
                });
                
                highlightMesh.visible = false;
                intersectedBlock = null;
                showMessage(`–î–≤–µ—Ä—å —Å–ª–æ–º–∞–Ω–∞!`);
                return;
            }
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–∏–Ω–∞–º–∏—Ç–∞
            if (mesh.userData.isTNT && mesh.userData.isActive) {
                const tntId = mesh.userData.tntId;
                if (activeTNTs.has(tntId)) {
                    clearTimeout(activeTNTs.get(tntId).timer);
                    activeTNTs.delete(tntId);
                }
            }
            
            const coords = mesh.userData.coords;
            scene.remove(mesh);
            worldBlocks.delete(coords);
            highlightMesh.visible = false;
            intersectedBlock = null;
            showMessage(`–ë–ª–æ–∫ ${BLOCK_TYPES[mesh.userData.typeId].name} —Å–ª–æ–º–∞–Ω!`);
        }
        
        function toggleFunctionalBlock(mesh) {
            if (mesh.userData.typeId === 6) { // –õ—é–∫
                mesh.userData.isOpen = !mesh.userData.isOpen;
                
                const blockInfo = BLOCK_TYPES[mesh.userData.typeId];
                if (mesh.userData.isOpen) {
                    mesh.material.color.set(0x4a2c16); // –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–≤–µ—Ç–∞ –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ –æ—Ç–∫—Ä—ã—Ç–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
                    showMessage("–õ—é–∫ –æ—Ç–∫—Ä—ã—Ç!");
                } else {
                    mesh.material.color.set(blockInfo.defaultColor); 
                    showMessage("–õ—é–∫ –∑–∞–∫—Ä—ã—Ç!");
                }
            } else if (mesh.userData.typeId === 11) { // –°—É–Ω–¥—É–∫
                toggleInventory(true);
                showMessage("–°—É–Ω–¥—É–∫ –æ—Ç–∫—Ä—ã—Ç! (–ü–µ—Ä–µ—Ö–æ–¥ –≤ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å)");
            } else if (mesh.userData.isDoor) { // –î–≤–µ—Ä—å
                const doorId = mesh.userData.doorId;
                let isAnyOpen = false;
                
                // –ù–∞—Ö–æ–¥–∏–º –æ–±–µ —á–∞—Å—Ç–∏ –¥–≤–µ—Ä–∏ –∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –∏—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                worldBlocks.forEach((block) => {
                    if (block.userData.doorId === doorId) {
                        block.userData.isOpen = !block.userData.isOpen;
                        if (block.userData.isOpen) {
                            block.material.color.set(0x5a3c26); // –¶–≤–µ—Ç –æ—Ç–∫—Ä—ã—Ç–æ–π –¥–≤–µ—Ä–∏
                            isAnyOpen = true;
                        } else {
                            block.material.color.set(BLOCK_TYPES[20].defaultColor); // –¶–≤–µ—Ç –∑–∞–∫—Ä—ã—Ç–æ–π –¥–≤–µ—Ä–∏
                        }
                    }
                });
                
                showMessage(isAnyOpen ? "–î–≤–µ—Ä—å –æ—Ç–∫—Ä—ã—Ç–∞!" : "–î–≤–µ—Ä—å –∑–∞–∫—Ä—ã—Ç–∞!");
            } else if (mesh.userData.typeId === 30) { // –ü–æ—Ä—Ç–∞–ª
                showMessage("–ü–æ—Ä—Ç–∞–ª –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! –¢–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏—è...");
                // –ü—Ä–æ—Å—Ç–∞—è —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏—è –Ω–∞ —Å–ª—É—á–∞–π–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
                const newX = (Math.random() * 40 - 20) * BLOCK_SIZE;
                const newZ = (Math.random() * 40 - 20) * BLOCK_SIZE;
                controls.getObject().position.set(newX, 5 * BLOCK_SIZE, newZ);
            } else if (mesh.userData.isTNT) { // –î–∏–Ω–∞–º–∏—Ç
                activateTNT(mesh);
            }
        }
        
        // --- –õ–æ–≥–∏–∫–∞ –ü—Ä–∏—Å–µ–¥–∞–Ω–∏—è (Crouching) ---
        function canStandUp(playerX, playerY, playerZ) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ç–≤–µ—Ä–¥—ã–π –±–ª–æ–∫ –Ω–∞–¥ –≥–æ–ª–æ–≤–æ–π –∏–≥—Ä–æ–∫–∞, –µ—Å–ª–∏ –æ–Ω –≤—Å—Ç–∞–Ω–µ—Ç.
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–æ—á–µ–∫ –Ω–∞ —É—Ä–æ–≤–Ω–µ –≥–æ–ª–æ–≤—ã
            const standUpHeadY = playerY + (PLAYER_HEIGHT - CROUCH_HEIGHT); 
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ Y-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –¥–ª—è –≤—ã—Å–æ–∫–æ–≥–æ –∏–≥—Ä–æ–∫–∞
            const checkYs = [];
            for (let i = 0; i < 3; i++) {
                const y = standUpHeadY + (i * BLOCK_SIZE / 2);
                checkYs.push(Math.round((y + 0.1) / BLOCK_SIZE) * BLOCK_SIZE + BLOCK_SIZE / 2);
            }

            for (let y of checkYs) {
                if (isBlockSolid(playerX, y, playerZ)) {
                    return false;
                }
            }
            return true;
        }

        function toggleCrouch(crouch) {
            if (crouch === isCrouching) return; 

            if (crouch) {
                // –ù–∞—á–∞—Ç—å –ø—Ä–∏—Å–µ–¥–∞–Ω–∏–µ
                isCrouching = true;
                currentHeight = CROUCH_HEIGHT;
                currentEyeHeight = CROUCH_EYE_HEIGHT;
                // –°–¥–≤–∏–≥ –∫–∞–º–µ—Ä—ã –≤–Ω–∏–∑
                controls.getObject().position.y -= (PLAYER_HEIGHT - CROUCH_HEIGHT);
            } else {
                // –ü–æ–ø—ã—Ç–∫–∞ –≤—Å—Ç–∞—Ç—å
                const playerObject = controls.getObject();
                
                if (canStandUp(playerObject.position.x, playerObject.position.y, playerObject.position.z)) {
                    // –í—Å—Ç–∞—Ç—å
                    isCrouching = false;
                    currentHeight = PLAYER_HEIGHT;
                    currentEyeHeight = EYE_HEIGHT;
                    // –°–¥–≤–∏–≥ –∫–∞–º–µ—Ä—ã –≤–≤–µ—Ä—Ö
                    controls.getObject().position.y += (PLAYER_HEIGHT - CROUCH_HEIGHT);
                } else {
                    // –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤—Å—Ç–∞—Ç—å, –ø–æ—Ç–æ–ª–æ–∫ —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–∏–π
                    isCrouching = true; // –û—Å—Ç–∞–µ–º—Å—è –≤ —Ä–µ–∂–∏–º–µ –ø—Ä–∏—Å–µ–¥–∞–Ω–∏—è
                    showMessage("–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤—Å—Ç–∞—Ç—å! –°–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–∏–π –ø–æ—Ç–æ–ª–æ–∫.");
                }
            }
        }

        // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏ –í–≤–æ–¥ ---

        function toggleInventory(shouldOpen) {
            isInventoryOpen = shouldOpen;
            const inventoryElement = document.getElementById('fullInventory');
            if (isInventoryOpen) {
                inventoryElement.style.display = 'flex';
                controls.unlock();
                if (isCrouching) toggleCrouch(false); 
            } else {
                inventoryElement.style.display = 'none';
                controls.lock();
            }
        }
        
        function onMouseWheel(event) {
            if (isInventoryOpen) return;
            if (!controls.isLocked) return;
            
            event.preventDefault();

            if (event.deltaY > 0) {
                selectedQuickbarSlot = (selectedQuickbarSlot + 1) % QUICKBAR_SIZE;
            } else if (event.deltaY < 0) {
                selectedQuickbarSlot = (selectedQuickbarSlot - 1 + QUICKBAR_SIZE) % QUICKBAR_SIZE;
            }
            
            selectedBlockId = quickbarBlocks[selectedQuickbarSlot];
            updateInventorySelection();
            updateBlockNameDisplay();
        }

        function onKeyDown(event) {
            if (isInventoryOpen) {
                if (event.code === 'KeyE' || event.code === 'Escape') {
                    toggleInventory(false);
                }
                return;
            }
            
            if (!controls.isLocked) return;

            // –í—ã–±–æ—Ä —Å–ª–æ—Ç–∞ 1-9
            if (event.code.startsWith('Digit') && event.key !== '0') {
                const slotIndex = parseInt(event.key) - 1;
                if (slotIndex >= 0 && slotIndex < QUICKBAR_SIZE) {
                    selectedQuickbarSlot = slotIndex;
                    selectedBlockId = quickbarBlocks[selectedQuickbarSlot];
                    updateInventorySelection();
                    updateBlockNameDisplay();
                }
            }
            
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space':
                    if (canJump === true) velocity.y += 15;
                    canJump = false;
                    break;
                case 'KeyE': toggleInventory(true); break;
                case 'KeyF': // –ê–∫—Ç–∏–≤–∞—Ü–∏—è –¥–∏–Ω–∞–º–∏—Ç–∞
                    if (intersectedBlock && intersectedBlock.userData.isTNT) {
                        activateTNT(intersectedBlock);
                    }
                    break;
                case 'F5': saveWorldToFile(); break; // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –º–∏—Ä–∞ –ø–æ F5
                case 'Escape': controls.unlock(); break;
                case 'ShiftLeft': toggleCrouch(true); break;
            }
        }

        function onKeyUp(event) {
            if (!controls.isLocked || isInventoryOpen) return;
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': toggleCrouch(false); break;
            }
        }

        function onMouseDown(event) {
            if (!controls.isLocked || isInventoryOpen) return;
            event.preventDefault();

            if (intersectedBlock) {
                if (event.button === 0) { // –õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏ (–õ–æ–º–∞—Ç—å)
                    removeBlock(intersectedBlock);
                } else if (event.button === 2) { // –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏ (–°—Ç–∞–≤–∏—Ç—å / –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å)
                    if (intersectedBlock.userData.isFunctional || intersectedBlock.userData.isDoor || intersectedBlock.userData.isTNT) {
                        toggleFunctionalBlock(intersectedBlock);
                    } else {
                        placeBlock(intersectedBlock, selectedBlockId);
                    }
                }
            }
        }
        
        // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é –ø—Ä–∏ –ø—Ä–∞–≤–æ–π –∫–Ω–æ–ø–∫–µ –º—ã—à–∏
        document.addEventListener('contextmenu', (event) => {
            if (controls.isLocked || isInventoryOpen) event.preventDefault();
        });

        function placeBlock(targetBlock, typeId) {
            if (!targetBlock) return;
            
            const selectedBlockInfo = BLOCK_TYPES[typeId];
            if (!selectedBlockInfo) return; 

            // –ù–∞—Ö–æ–¥–∏–º —Ç–æ—á–∫—É, –∫—É–¥–∞ –Ω—É–∂–Ω–æ —Å—Ç–∞–≤–∏—Ç—å –±–ª–æ–∫ (—Å–º–µ—â–µ–Ω–∏–µ –Ω–∞ 1 –±–ª–æ–∫ –æ—Ç –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏)
            const intersection = raycaster.intersectObject(targetBlock)[0];
            if (!intersection) return;

            const faceNormal = intersection.face.normal;
            const newPos = targetBlock.position.clone();

            newPos.x += faceNormal.x * BLOCK_SIZE;
            newPos.y += faceNormal.y * BLOCK_SIZE;
            newPos.z += faceNormal.z * BLOCK_SIZE;
            
            // --- –ü—Ä–æ–≤–µ—Ä–∫–∞ AABB –Ω–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –∏–≥—Ä–æ–∫–æ–º ---
            const playerPos = controls.getObject().position;
            const playerMinX = playerPos.x - PLAYER_HALF_WIDTH;
            const playerMaxX = playerPos.x + PLAYER_HALF_WIDTH;
            // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è Y-–ø—Ä–æ–≤–µ—Ä–∫–∞ —Å —É—á–µ—Ç–æ–º –ø—Ä–∏—Å–µ–¥–∞–Ω–∏—è
            const playerMinY = playerPos.y - currentEyeHeight; 
            const playerMaxY = playerPos.y + (currentHeight - currentEyeHeight);

            const blockHalfSize = BLOCK_SIZE / 2;
            const blockMinX = newPos.x - blockHalfSize;
            const blockMaxX = newPos.x + blockHalfSize;
            const blockMinY = newPos.y - blockHalfSize;
            const blockMaxY = newPos.y + blockHalfSize;
            const blockMinZ = newPos.z - blockHalfSize;
            const blockMaxZ = newPos.z + blockHalfSize;

            const intersectsX = blockMinX < playerMaxX && blockMaxX > playerMinX;
            const intersectsY = blockMinY < playerMaxY && blockMaxY > playerMinY; 
            const intersectsZ = blockMinZ < playerPos.z + PLAYER_HALF_WIDTH && blockMaxZ > playerPos.z - PLAYER_HALF_WIDTH;

            if (intersectsX && intersectsY && intersectsZ) {
                showMessage("–ù–µ–ª—å–∑—è —Å—Ç–∞–≤–∏—Ç—å –±–ª–æ–∫ –≤–Ω—É—Ç—Ä–∏ —Å–µ–±—è!");
                return;
            }
            
            addBlock(newPos.x, newPos.y, newPos.z, typeId);
            showMessage(`–ë–ª–æ–∫ ${selectedBlockInfo.name} —Ä–∞–∑–º–µ—â–µ–Ω.`);
        }

        // --- –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å UI ---

        function setupInventory() {
            const inventoryDiv = document.getElementById('inventory');
            const fullInventoryGrid = document.getElementById('inventoryGrid');
            inventoryDiv.innerHTML = '';
            fullInventoryGrid.innerHTML = '';

            // 1. –ë—ã—Å—Ç—Ä–∞—è –ø–∞–Ω–µ–ª—å (Quickbar)
            for (let i = 0; i < QUICKBAR_SIZE; i++) {
                const id = quickbarBlocks[i];
                const info = BLOCK_TYPES[id];
                const button = document.createElement('div');
                button.className = `block-item w-16 h-16 rounded-lg flex items-center justify-center shadow-xl border-4 border-transparent p-1`;
                button.style.backgroundColor = `#${info.defaultColor.toString(16).padStart(6, '0')}`;
                button.dataset.slotIndex = i;
                button.dataset.blockId = id;
                button.title = info.name + ` (${i + 1})`;
                
                button.innerHTML = `
                    <span class="absolute top-0 left-1 text-white text-sm font-bold drop-shadow-lg">${i + 1}</span>
                `; 
                
                button.addEventListener('click', () => {
                    selectedQuickbarSlot = i;
                    selectedBlockId = id;
                    updateInventorySelection();
                    updateBlockNameDisplay();
                });
                inventoryDiv.appendChild(button);
            }

            // 2. –ü–æ–ª–Ω—ã–π –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å (Grid)
            Object.entries(BLOCK_TYPES).forEach(([id, info]) => {
                const blockId = parseInt(id);
                const slot = document.createElement('div');
                slot.className = `inventory-slot bg-gray-700 hover:bg-gray-600 relative`;
                slot.style.backgroundColor = `#${info.defaultColor.toString(16).padStart(6, '0')}`;
                slot.title = info.name;
                slot.innerHTML = `<span class="text-white text-sm font-semibold">${info.name}</span>`;
                
                slot.addEventListener('click', () => {
                    quickbarBlocks[selectedQuickbarSlot] = blockId;
                    selectedBlockId = blockId;
                    setupInventory(); 
                    updateInventorySelection();
                    updateBlockNameDisplay();
                    toggleInventory(false); 
                });
                fullInventoryGrid.appendChild(slot);
            });
        }

        function updateInventorySelection() {
            document.querySelectorAll('.block-item').forEach(item => {
                item.classList.remove('selected-block');
                if (parseInt(item.dataset.slotIndex) === selectedQuickbarSlot) {
                    item.classList.add('selected-block');
                }
            });
        }
        
        function updateBlockNameDisplay() {
            const name = BLOCK_TYPES[selectedBlockId].name;
            document.getElementById('blockNameDisplay').textContent = name;
        }

        // --- –ê–Ω–∏–º–∞—Ü–∏–æ–Ω–Ω—ã–π –¶–∏–∫–ª –∏ –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ ---

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            
            if (controls.isLocked && !isInventoryOpen) {
                
                // 1. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ —Ç—Ä–µ–Ω–∏—è
                const speed = isCrouching ? MAX_SPEED * CROUCH_SPEED_FACTOR : MAX_SPEED;
                const acceleration = 40.0; 
                const dampingFactor = 10.0;
                
                velocity.x -= velocity.x * dampingFactor * delta; 
                velocity.z -= velocity.z * dampingFactor * delta; 

                // –£—Å–∫–æ—Ä–µ–Ω–∏–µ
                if (moveForward) velocity.z = Math.min(velocity.z + acceleration * delta, speed); 
                if (moveBackward) velocity.z = Math.max(velocity.z - acceleration * delta, -speed);
                
                // –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –ª–æ–≥–∏–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è A/D, —á—Ç–æ–±—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å Minecraft
                if (moveLeft) velocity.x = Math.min(velocity.x + acceleration * delta, speed);
                if (moveRight) velocity.x = Math.max(velocity.x - acceleration * delta, -speed);
                
                // 2. –†–∞—Å—á–µ—Ç –º–∏—Ä–æ–≤–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
                const moveZLocal = velocity.z * delta; 
                const moveXLocal = velocity.x * delta; 
                
                const playerObject = controls.getObject();
                const playerX = playerObject.position.x;
                const playerZ = playerObject.position.z;
                
                // –í–µ–∫—Ç–æ—Ä "–í–ø–µ—Ä–µ–¥"
                playerObject.getWorldDirection(forwardVector); 
                // –í–µ–∫—Ç–æ—Ä "–í–ø—Ä–∞–≤–æ"
                rightVector.set(forwardVector.z, 0, -forwardVector.x).normalize();
                
                // –†–∞—Å—á–µ—Ç —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –¥–≤–∏–∂–µ–Ω–∏—è –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
                const moveXWorld = (forwardVector.x * moveZLocal) + (rightVector.x * moveXLocal);
                const moveZWorld = (forwardVector.z * moveZLocal) + (rightVector.z * moveXLocal);

                let nextX = playerX + moveXWorld;
                let nextZ = playerZ + moveZWorld;
                
                // --- Y-–£—Ä–æ–≤–Ω–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ–ª–ª–∏–∑–∏–π ---
                // –î–ª—è –≤—ã—Å–æ–∫–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –±–æ–ª—å—à–µ —Ç–æ—á–µ–∫ –ø–æ –≤—ã—Å–æ—Ç–µ
                const playerY = playerObject.position.y;
                const checkPoints = [];
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–æ—á–µ–∫ –ø–æ –≤—ã—Å–æ—Ç–µ –∏–≥—Ä–æ–∫–∞
                for (let i = 0; i < 3; i++) {
                    const yOffset = (i / 2) * (currentHeight - currentEyeHeight);
                    checkPoints.push(
                        Math.round((playerY - currentEyeHeight + yOffset + 0.1) / BLOCK_SIZE) * BLOCK_SIZE + BLOCK_SIZE / 2
                    );
                }
                
                // --- 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –õ–µ—Å—Ç–Ω–∏—Ü—É (Climbing) ---
                let onLadder = false;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –∏–≥—Ä–æ–∫ –Ω–∞ –ª–µ—Å—Ç–Ω–∏—Ü–µ (–∫–æ–ª–ª–∏–∑–∏—è —Å Y-—É—Ä–æ–≤–Ω—è–º–∏)
                checkPoints.forEach(y => {
                    const block = getBlockAtCoords(playerX, y, playerZ);
                    if (block && BLOCK_TYPES[block.userData.typeId].isClimbable) {
                        onLadder = true;
                    }
                });
                
                if (onLadder) {
                    canJump = true; 
                    velocity.y = 0; 
                    const climbSpeed = 5.0; 

                    if (moveForward) {
                        velocity.y = climbSpeed;
                    } else if (moveBackward) {
                        velocity.y = -climbSpeed;
                    } 
                } else {
                    // –ù–æ—Ä–º–∞–ª—å–Ω–∞—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                    velocity.y -= GRAVITY_CONSTANT * delta; 
                }

                // --- 3. –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –ö–æ–ª–ª–∏–∑–∏—è (X/Z) ---

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ X-–∫–æ–ª–ª–∏–∑–∏–∏
                if (Math.abs(moveXWorld) > 0.001) {
                    const checkZOffsets = [-COLLISION_CHECK_OFFSET, 0, COLLISION_CHECK_OFFSET];
                    let isColliding = false;

                    for (let zOffset of checkZOffsets) {
                        const checkBlockX = nextX + (moveXWorld > 0 ? PLAYER_HALF_WIDTH : -PLAYER_HALF_WIDTH);
                        const blockXCenter = Math.round(checkBlockX / BLOCK_SIZE) * BLOCK_SIZE;
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ —Ç–æ—á–∫–∏ –ø–æ –≤—ã—Å–æ—Ç–µ
                        for (let y of checkPoints) {
                            const blockZCenter = Math.round((playerZ + zOffset) / BLOCK_SIZE) * BLOCK_SIZE;
                            if (isBlockSolid(blockXCenter, y, blockZCenter)) {
                                isColliding = true;
                                break;
                            }
                        }
                        if (isColliding) break;
                    }
                    
                    if (isColliding) {
                        velocity.x = 0; 
                        nextX = playerX; 
                    }
                }

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ Z-–∫–æ–ª–ª–∏–∑–∏–∏
                if (Math.abs(moveZWorld) > 0.001) {
                    const checkXOffsets = [-COLLISION_CHECK_OFFSET, 0, COLLISION_CHECK_OFFSET];
                    let isColliding = false;

                    for (let xOffset of checkXOffsets) {
                        const checkBlockZ = nextZ + (moveZWorld > 0 ? PLAYER_HALF_WIDTH : -PLAYER_HALF_WIDTH);
                        const blockZCenter = Math.round(checkBlockZ / BLOCK_SIZE) * BLOCK_SIZE;
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ —Ç–æ—á–∫–∏ –ø–æ –≤—ã—Å–æ—Ç–µ
                        for (let y of checkPoints) {
                            const blockXCenter = Math.round((nextX + xOffset) / BLOCK_SIZE) * BLOCK_SIZE; 
                            if (isBlockSolid(blockXCenter, y, blockZCenter)) {
                                isColliding = true;
                                break;
                            }
                        }
                        if (isColliding) break;
                    }
                    
                    if (isColliding) {
                        velocity.z = 0; 
                        nextZ = playerZ; 
                    }
                }
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
                playerObject.position.x = nextX;
                playerObject.position.z = nextZ;

                // --- 4. –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –∫–æ–ª–ª–∏–∑–∏—è (–õ—ç–Ω–¥–∏–Ω–≥/–ü–æ—Ç–æ–ª–æ–∫) ---
                
                let nextY = playerObject.position.y + (velocity.y * delta);
                
                if (velocity.y < 0) {
                    // –õ—ç–Ω–¥–∏–Ω–≥
                    const nextFeetY = nextY - currentEyeHeight; 
                    const floorBlockYCenter = Math.floor(nextFeetY / BLOCK_SIZE) * BLOCK_SIZE + BLOCK_SIZE / 2;

                    if (isBlockSolid(playerX, floorBlockYCenter, playerZ)) {
                        const surfaceY = floorBlockYCenter + BLOCK_SIZE / 2;
                        if (nextFeetY < surfaceY) {
                            velocity.y = 0;
                            nextY = surfaceY + currentEyeHeight; 
                            canJump = true;
                        }
                    }
                } else if (velocity.y > 0) {
                    // –£–¥–∞—Ä –≥–æ–ª–æ–≤–æ–π - –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –≤–µ—Ä—Ö–Ω–∏–µ —Ç–æ—á–∫–∏
                    let headCollision = false;
                    let minCeilingY = Infinity;
                    
                    for (let i = 0; i < 3; i++) {
                        const headYOffset = (i / 2) * (currentHeight - currentEyeHeight);
                        const nextHeadY = nextY + headYOffset; 
                        const ceilingBlockYCenter = Math.floor(nextHeadY / BLOCK_SIZE) * BLOCK_SIZE + BLOCK_SIZE / 2;
                        
                        if (isBlockSolid(playerX, ceilingBlockYCenter, playerZ)) {
                            headCollision = true;
                            const ceilingSurfaceY = ceilingBlockYCenter - BLOCK_SIZE / 2;
                            minCeilingY = Math.min(minCeilingY, ceilingSurfaceY - headYOffset);
                        }
                    }
                    
                    if (headCollision) {
                        velocity.y = 0; 
                        nextY = Math.min(nextY, minCeilingY);
                    }
                }
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é Y-–ø–æ–∑–∏—Ü–∏—é
                playerObject.position.y = nextY; 

                // 5. –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–∞–¥–µ–Ω–∏—è (Fall Protection)
                const groundSurfaceY = BLOCK_SIZE + BLOCK_SIZE / 2;
                if (playerObject.position.y < groundSurfaceY + currentEyeHeight) {
                    playerObject.position.y = groundSurfaceY + currentEyeHeight;
                    velocity.y = 0;
                    canJump = true;
                }

                // --- –õ–æ–≥–∏–∫–∞ Raycasting (–í—ã–¥–µ–ª–µ–Ω–∏–µ –±–ª–æ–∫–∞) ---
                raycaster.setFromCamera({ x: 0, y: 0 }, camera);
                
                const intersectableObjects = Array.from(worldBlocks.values());
                const intersects = raycaster.intersectObjects(intersectableObjects);

                if (intersects.length > 0) {
                    const firstHit = intersects[0];
                    if (intersectedBlock !== firstHit.object) {
                        intersectedBlock = firstHit.object;
                        highlightMesh.visible = true;
                        highlightMesh.position.copy(intersectedBlock.position);
                    }
                } else {
                    intersectedBlock = null;
                    highlightMesh.visible = false;
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // –ó–∞–ø—É—Å–∫
        window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>
